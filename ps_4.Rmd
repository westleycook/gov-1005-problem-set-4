---
title: "Problem Set 4"
author: "Westley Cook"
date: "3/4/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(tidycensus)
library(scales)
options(scipen=999)
library(gt)
library(magrittr)
library(gridExtra)

income <- get_acs(geography = "county", 
                  variables = 'B19013_001', 
                  year = 2018, 
                  geometry = TRUE)

```

## Question 1: Mad Libs

```{r mad-lib-1, echo=FALSE}

# This function should take a numeric vector (like our column, estimate) and 
# calculate the standard deviation of the variable, then adds 1.

# Debugging: took the + 1 out of parenthesis, added closing parenthesis after
# return(x)

sd_plus_one <- function(var, na.rm = TRUE){
  x<- sd(var, na.rm = na.rm) + 1
  return(x)
  }

answer_1 <- sd_plus_one(var = income$estimate) %>% 
  round(digits = 2)

```

##### **ML1)** 

The standard deviation of median income, plus one, is **`r answer_1`**.

```{r mad-lib-2, echo=FALSE}

# This function should take a county and state pair and extracts just the state
# name. We can do this easily because the state name is always after a comma and
# space.

# Debugging: added pipe operator after countystate

 get_state <- function(countystate){
  countystate %>% 
  str_split_fixed(.,", ", 2) %>% 
  pluck(2) %>% 
  return()
 }

answer_2 <- get_state("Treasure County, Montana")

```

##### **ML 2)** 

Treasure County, Montana is located in the state of **`r answer_2`**.

```{r mad-lib-3, echo=FALSE}

# This function should take the geoid for a given county, grabs the median income for the 
# corresponding county, and then add the margin of error to the value. 

# Debugging: changed function parameter from x to geoid

upper_bound <- function(geoid){
 income %>% 
 filter(GEOID == geoid) %>% 
 mutate(estimate + moe) %>% 
 pull()
}

answer_3 <- upper_bound(geoid = "01005")

```

##### **ML 3)**

The upper bound for median income in Etowah County, Alabama (geoid = “01055”) is **`r answer_3`**.

## Question 2: Mapping

```{r question_2, echo=FALSE}

cali_by_county <- income %>% 
  separate(col = NAME, into = c("county_name", "state"), sep = ", ") %>% 
  filter(state == "California")

cali_by_county %>%
  ggplot(aes(fill = estimate)) +
  geom_sf() + 
  scale_fill_viridis_c(option = "plasma",
                       direction = -1,
                       labels = comma) +
  labs(title = "Median Income by County in California",
       caption = "Source: American Communities Survey 2018",
       fill = "Median Income") +
  theme_void()


```


## Question 3: Publishing to Rpubs

##### View my published plot at https://rpubs.com/wkcook/580806

## Question 4: Tufte Reading

The California Tax PowerPoint seems to be a gross oversimplification of a very complex issue, and Tufte would have a heyday critiquing it. As he suggests is common, the bullet structure of the information in this PPT leads to simple statements that tell the reader very little (e.g. “The State Has a Sound Tax System,” slide 19). He would be disgusted with the visuals, since they have very few numbers and seem to be in the PPT for show (ooh, look, a chart!) rather than for substance; particularly bad is the pie chart on slide 14, which doesn’t have any numbers at all! What’s more, the logo in the bottom right corner of each slide takes up valuable space, making the PPT look like an advertisement for LAO more than an instructional or information-sharing tool.

Perhaps the best way to improve the PPT, as Tufte suggests, would be to get rid of it entirely in favor of an 8 x 11 paper handout. Such a handout could, for example, have a list of tax acronyms (PIT, SUT, CT, etc.) used throughout the presentation so attendees could refresh their memories each time one was mentioned; this would make it less likely they would forget the acronyms immediately after their initial introduction (which I did, when reading the PPT slides). It could also hold a more complete table showing the effects of change in personal income on change in revenues (slide 9) and an easier-to-read version of the tax expenditure chart on slide 18.

## Question 5: Writing a Function

### 5a

```{r question_5a, echo=FALSE}

get_letters <- function(n) {
  stopifnot(is.numeric(n))
  sample(letters, size = n, replace = TRUE) %>% 
    min()
}

```

A call of my function get_letters with n = 3 produces the output 
"**`r get_letters(3)`**".

### 5b

```{r question_5b, echo=FALSE}

roll_alpha_dice <- function(n) {
  stopifnot(is.numeric(n))
  map_chr(rep(3, n), get_letters)
}

```

I wrote a cool function called roll_alpha_dice. Check it out in 5c.

### 5c

```{r question_5c, echo=FALSE}

tf_game <- tibble(throws = map(rep(3, 100), ~ roll_alpha_dice(4)))

tf_game %>% 
  slice(1:5) %>% 
  gt() %>% 
  tab_header(title = "Throws of the Alpha Dice",
             subtitle = "Four players taking the alphabetically earliest of 
             three rolls") %>% 
  cols_label(throws = "Throws") %>% 
  tab_footnote(footnote = "First five of 100 rows are shown",
               locations = cells_title("title"))

tf_game %<>% 
  mutate(vowel = map_lgl(throws, 
                         ~ ifelse(.[[1]] %in% c("a", "e", "i", "o", "u"), 
                                  TRUE,
                                  FALSE))) %>% 
  filter(vowel == TRUE) %>% 
  count() %>% 
  pull(n)

```

I had **`r tf_game`** vowels.

### 5d

```{r question_5d, echo=FALSE}

surprised <- tibble(throws = map(rep(3, 10000), ~ roll_alpha_dice(4))) %>% 
  mutate(all_vowels = map_lgl(throws, 
                              ~ ifelse(all(. %in% c("a", "e", "i", "o", "u")), 
                                  TRUE,
                                  FALSE)))

prob_all_vowels <- surprised %>% 
  pull(all_vowels) %>% 
  mean()


```

The probability that all four TF's roll a vowel is approximately 
**`r prob_all_vowels`**.

### 5e

```{r question_5e, echo=FALSE}

first_letters <- tibble(throws = map(rep(3, 1000), ~ roll_alpha_dice(1))) %>% 
  unnest(throws)

first_letters %>% 
  ggplot(aes(throws)) +
  geom_bar() +
  theme_classic() +
  labs(title = 'Distribution of "First" Letters in 1,000 Rolls of 3 Dice',
       x = "Letter Rolled",
       y = "Count")

```

### 5f

```{r question_5f, echo=FALSE}

roll_alpha_dice_5 <- function(n) {
  stopifnot(is.numeric(n))
  map_chr(rep(5, n), get_letters)
}

first_letters_5dice <- tibble(throws = map(rep(5, 1000),
                                           ~ roll_alpha_dice_5(1))) %>% 
  unnest(throws)

plot_3_dice <- first_letters %>% 
  ggplot(aes(throws)) +
  geom_bar() +
  theme_classic() +
  labs(title = 'Distribution of "First" Letters, 3 Dice',
       x = "Letter Rolled",
       y = "Count") +
  scale_y_continuous(limits = c(0, 200))

plot_5_dice <- first_letters_5dice %>% 
  ggplot(aes(throws)) +
  geom_bar() +
  theme_classic() +
  labs(title = 'Distribution of "First" Letters, 5 Dice',
       x = "Letter Rolled",
       y = "Count") +
  scale_y_continuous(limits = c(0, 200))

gridExtra::grid.arrange(plot_3_dice, plot_5_dice, ncol = 2)

```

When using five dice instead of three, the distribution compresses toward the left: the counts of the earlier letters (a, b, c, etc.) increase relative to their counts when only three dice are used, and the counts of later letters (z, y, x, etc.) decrease - to the point that fewer unique letters are rolled at all when 5 dice are used.