---
title: "Problem Set 4"
author: "Westley Cook"
date: "3/4/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(tidycensus)
library(scales)
options(scipen=999)
library(gt)
library(magrittr)
library(gridExtra)

income <- get_acs(geography = "county", 
                  variables = 'B19013_001', 
                  year = 2018, 
                  geometry = TRUE)

```

## Question 1: Mad Libs

```{r mad-lib-1, echo=FALSE}

# This function should take a numeric vector (like our column, estimate) and 
# calculate the standard deviation of the variable, then adds 1.

# Debugging: took the + 1 out of parenthesis, added closing parenthesis after
# return(x)

sd_plus_one <- function(var, na.rm = TRUE){
  x<- sd(var, na.rm = na.rm) + 1
  return(x)
  }

answer_1 <- sd_plus_one(var = income$estimate) %>% 
  round(digits = 2)

```

##### **ML1)** 

The standard deviation of median income, plus one, is **`r answer_1`**.

```{r mad-lib-2, echo=FALSE}

# This function should take a county and state pair and extracts just the state
# name. We can do this easily because the state name is always after a comma and
# space.

# Debugging: added pipe operator after countystate

 get_state <- function(countystate){
  countystate %>% 
  str_split_fixed(.,", ", 2) %>% 
  pluck(2) %>% 
  return()
 }

answer_2 <- get_state("Treasure County, Montana")

```

##### **ML 2)** 

Treasure County, Montana is located in the state of **`r answer_2`**.

```{r mad-lib-3, echo=FALSE}

# This function should take the geoid for a given county, grabs the median income for the 
# corresponding county, and then add the margin of error to the value. 

# Debugging: changed function parameter from x to geoid

upper_bound <- function(geoid){
 income %>% 
 filter(GEOID == geoid) %>% 
 mutate(estimate + moe) %>% 
 pull()
}

answer_3 <- upper_bound(geoid = "01005")

```

##### **ML 3)**

The upper bound for median income in Etowah County, Alabama (geoid = “01055”) is **`r answer_3`**.

## Question 2: Mapping

```{r question_2, echo=FALSE}

cali_by_county <- income %>% 
  separate(col = NAME, into = c("county_name", "state"), sep = ", ") %>% 
  filter(state == "California")

cali_by_county %>%
  ggplot(aes(fill = estimate)) +
  geom_sf() + 
  scale_fill_viridis_c(option = "plasma",
                       direction = -1,
                       labels = comma) +
  labs(title = "Median Income by County in California",
       caption = "Source: American Communities Survey 2018",
       fill = "Median Income") +
  theme_void()


```


## Question 3: Publishing to Rpubs

##### View my published plot at https://rpubs.com/wkcook/580806

## Question 4: Tufte Reading

[Write a paragraph here]

Write a short paragraph (max 250 words – parsimony is a virtue!) critiquing the california_tax Powerpoint included in this directory, using the Tufte reading as your guide. Be sure to provide thoughts on the numeric content of the visuals, the role of logos, and the bullet structure of the information. Give at least one suggestion of how some information in the Powerpoint could be better transmitted in an 8 x 11 handout.

## Question 5: Writing a Function

### 5a

```{r question_5a, echo=FALSE}

get_letters <- function(n) {
  stopifnot(is.numeric(n))
  sample(letters, size = n, replace = TRUE) %>% 
    min()
}

```

A call of my function get_letters with n = 3 produces the output 
"**`r get_letters(3)`**".

### 5b

```{r question_5b, echo=FALSE}

roll_alpha_dice <- function(n) {
  stopifnot(is.numeric(n))
  map_chr(rep(3, n), get_letters)
}

```

I wrote a cool function called roll_alpha_dice. Check it out in 5c.

### 5c

```{r question_5c, echo=FALSE}

tf_game <- tibble(throws = map(rep(3, 100), ~ roll_alpha_dice(4)))

tf_game %>% 
  slice(1:5) %>% 
  gt() %>% 
  tab_header(title = "Throws of the Alpha Dice",
             subtitle = "Four players taking the alphabetically earliest of 
             three rolls") %>% 
  cols_label(throws = "Throws") %>% 
  tab_footnote(footnote = "First five of 100 rows are shown",
               locations = cells_title("title"))

tf_game %<>% 
  mutate(vowel = map_lgl(throws, 
                         ~ ifelse(.[[1]] %in% c("a", "e", "i", "o", "u"), 
                                  TRUE,
                                  FALSE))) %>% 
  filter(vowel == TRUE) %>% 
  count() %>% 
  pull(n)

```

I had **`r tf_game`** vowels.

### 5d

```{r question_5d, echo=FALSE}

surprised <- tibble(throws = map(rep(3, 10000), ~ roll_alpha_dice(4))) %>% 
  mutate(all_vowels = map_lgl(throws, 
                              ~ ifelse(all(. %in% c("a", "e", "i", "o", "u")), 
                                  TRUE,
                                  FALSE)))

prob_all_vowels <- surprised %>% 
  pull(all_vowels) %>% 
  mean()


```

The probability that all four TF's roll a vowel is approximately 
**`r prob_all_vowels`**.

### 5e

```{r question_5e, echo=FALSE}

first_letters <- tibble(throws = map(rep(3, 1000), ~ roll_alpha_dice(1))) %>% 
  unnest(throws)

first_letters %>% 
  ggplot(aes(throws)) +
  geom_bar() +
  theme_classic() +
  labs(title = 'Distribution of "First" Letters in 1,000 Rolls of 3 Dice',
       x = "Letter Rolled",
       y = "Count")

```

### 5f

```{r question_5f, echo=FALSE}

roll_alpha_dice_5 <- function(n) {
  stopifnot(is.numeric(n))
  map_chr(rep(5, n), get_letters)
}

first_letters_5dice <- tibble(throws = map(rep(5, 1000),
                                           ~ roll_alpha_dice_5(1))) %>% 
  unnest(throws)

plot_3_dice <- first_letters %>% 
  ggplot(aes(throws)) +
  geom_bar() +
  theme_classic() +
  labs(title = 'Distribution of "First" Letters, 3 Dice',
       x = "Letter Rolled",
       y = "Count") +
  scale_y_continuous(limits = c(0, 200))

plot_5_dice <- first_letters_5dice %>% 
  ggplot(aes(throws)) +
  geom_bar() +
  theme_classic() +
  labs(title = 'Distribution of "First" Letters, 5 Dice',
       x = "Letter Rolled",
       y = "Count") +
  scale_y_continuous(limits = c(0, 200))

gridExtra::grid.arrange(plot_3_dice, plot_5_dice, ncol = 2)

```

When using five dice instead of three, the distribution compresses toward the left: the counts of the earlier letters (a, b, c, etc.) increase relative to their counts when only three dice are used, and the counts of later letters (z, y, x, etc.) decrease - to the point that fewer unique letters are rolled at all when 5 dice are used.