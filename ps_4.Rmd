---
title: "Problem Set 4"
author: "Westley Cook"
date: "3/4/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# This r chunk loads necessary packages and changes default setting out of
# scientific notation.

# Loading tidyverse as a base to get me started

library(tidyverse)

# Loading tidycensus for use in the mad libs secion

library(tidycensus)

# Loading scales for use in question 2 plot formatting

library(scales)

# Loading gt for use in question 5c where I make a nice table

library(gt)

# Loading gridExtra to use grid.arrange() to put plots side by side in 5f

library(gridExtra)

# Changing out of scientific notation, which mostly helps with formatting mad
# lib answers

options(scipen=999)

```

## Question 1: Mad Libs

```{r load-data, include=FALSE}

# This r chunk gets county-level data from the ACS on median household income
# (variables = 'B1903_001') in 2018 and names it income. It's in its own r chunk
# so I can use include=FALSE to block the auto-generated message output from
# calling get_acs(). This seemed to be the easiest and most efficient way to
# block the long strings of output generated by get_acs(), including a progress
# bar showing how much has been downloaded.

income <- get_acs(geography = "county", 
                  variables = 'B19013_001', 
                  year = 2018, 
                  
# Realized when I started question 2 that I hadn't initially included geometry;
# added it then, as its data is essential for mapping
                  
                  geometry = TRUE)

```

```{r mad-lib-1, echo=FALSE}

# This r chunk debugs the code from mad lib 1 and assigns the answer to an
# object (answer_1) which is inserted in-line.

# Explanatory comment, copied from pset prompt: 
# This function should take a numeric vector (like our column, estimate) and
# calculate the standard deviation of the variable, then add 1.

# Debugging: took the + 1 out of parenthesis, added closing parenthesis after
# return(x)

sd_plus_one <- function(var, na.rm = TRUE){
  x<- sd(var, na.rm = na.rm) + 1
  return(x)
}

# Using the debugged function to take the standard deviation plus one of
# estimate, rounding it at the decimal point (arbitrary, but I think it looks
# better, and nobody's going to use this number for precise calculation that
# require a decimal point), and formatting to add a comma.

answer_1 <- sd_plus_one(var = income$estimate) %>% 
  round(digits = 0) %>% 
  formatC(format="d", big.mark=",")

```

##### **ML1)** 

The standard deviation of median income, plus one, is **`r answer_1`**.

```{r mad-lib-2, echo=FALSE}

# This r chunk debugs the code from mad lib 2 and assigns the answer to an
# object (answer_2) which is inserted in-line.

# Explanatory comment, copied from pset prompt: 
# This function should take a county and state pair and extract just the state
# name. We can do this easily because the state name is always after a comma and
# space.

# Debugging: added pipe operator after countystate

 get_state <- function(countystate){
  countystate %>% 
  str_split_fixed(.,", ", 2) %>% 
  pluck(2) %>% 
  return()
 }

# Using get_state to take just the state name from Montana and assign it to
# answer_2 so I can insert answer_2 in-line below

answer_2 <- get_state("Treasure County, Montana")

```

##### **ML 2)** 

Treasure County, Montana is located in the state of **`r answer_2`**.

```{r mad-lib-3, echo=FALSE}

# This r chunk debugs the code from mad lib 3 and assigns the answer to an
# object (answer_3) which is inserted in-line.

# Explanatory comment, copied from pset prompt: 
# This function should take the geoid for a given county, grabs the median
# income for the corresponding county, and then add the margin of error to the
# value.

# Debugging: changed function parameter from x to geoid

# Thought at this point about running clean_names() so I wouldn't have to deal
# with the all-caps column name, but decided since I was almost done working
# with this data that it wasn't necessary.

upper_bound <- function(geoid){
 income %>% 
 filter(GEOID == geoid) %>% 
 mutate(estimate + moe) %>% 
 pull()
}

# Using my upper_bound function to assign the upper bound of geoid = 01005 to
# answer_3, formatting to add a comma.To adjust for the typo in the prompt and
# figure out which county was actually being pulled by geoid = "01005", I
# filtered income by (GEOID == "01005") and looked at the name of the county. I
# then replaced "Etowah County" in the output for ML3 with "Barbour County."

answer_3 <- upper_bound(geoid = "01005") %>% 
  formatC(format="d", big.mark=",")

```

##### **ML 3)**

The upper bound for median income in Barbour County, Alabama (geoid = “01005”) 
is **`r answer_3`**.

## Question 2: Mapping

```{r question_2, echo=FALSE}

# This r chunk creates a new dataframe (cali_by_county) by taking a subset of
# the income dataframe.

# Had to spend some time reading about the separate() function to get this to
# work properly, but I got there once I realized I could use c() to put the
# names of two new columns inside the into= argument - which allowed me to keep
# both county name and state as variables. It was easy after that to filter out
# every state except California.

cali_by_county <- income %>% 
  separate(col = NAME, into = c("county_name", "state"), sep = ", ") %>% 
  filter(state == "California")

# As mentioned above, I struggled a bit at first because I'd originally
# forgotten to use (geometry = TRUE) with the get_acs() command. Once I added
# that, it was easy to map California by county, reflecting estimated median
# income using fill.

cali_by_county %>%
  ggplot(aes(fill = estimate)) +
  geom_sf() + 
  
# This code was taken from the example in PPBDS, but I added labels = comma to
# insert the commas into the numeric elements on the legend's scale (which makes
# it much easier to read at a glance).
  
  scale_fill_viridis_c(option = "plasma",
                       direction = -1,
                       labels = comma) +
  
# Adding labels, taking the text from the in-assignment plot I'm replicating  
  
  labs(title = "Median Income by County in California",
       caption = "Source: American Communities Survey 2018",
       fill = "Median Income") +
  
# And setting the theme to void, per suggestion of PPBDS, which easily gets rid
# of the axes and grid lines and background colors and such
  
  theme_void()


```

## Question 3: Publishing to Rpubs

```{r question_3, echo=FALSE}

# I copied and pasted code relevant to the plot in question 2 into a separate
# file, ps_4_rpub.Rmd, per the recommendation on the pset. I published from
# there, and put the link to the published graphic below. ps_4_rpub.Rmd and its
# accompanying .html file are committed to the repo as part of this project, and
# for easy replication should anyone want to do that.

```

##### View my published plot at https://rpubs.com/wkcook/580806

## Question 4: Tufte Reading

The California Tax PowerPoint seems to be a gross oversimplification of a very complex issue, and Tufte would have a heyday critiquing it. As he suggests is common, the bullet structure of the information in this PPT leads to simple statements that tell the reader very little (e.g. “The State Has a Sound Tax System,” slide 19). He would be disgusted with the visuals, since they have very few numbers and seem to be in the PPT for show (ooh, look, a chart!) rather than for substance; particularly bad is the pie chart on slide 14, which doesn’t have any numbers at all! What’s more, the logo in the bottom right corner of each slide takes up valuable space, making the PPT look like an advertisement for LAO more than an instructional or information-sharing tool.

Perhaps the best way to improve the PPT, as Tufte suggests, would be to get rid of it entirely in favor of an 8 x 11 paper handout. Such a handout could, for example, have a list of tax acronyms (PIT, SUT, CT, etc.) used throughout the presentation so attendees could refresh their memories each time one was mentioned; this would make it less likely they would forget the acronyms immediately after their initial introduction (which I did, when reading the PPT slides). It could also hold a more complete table showing the effects of change in personal income on change in revenues (slide 9) and an easier-to-read version of the tax expenditure chart on slide 18.

## Question 5: Writing a Function

### 5a

```{r question_5a, echo=FALSE}

# This r chunk writes my get_letters() function. I call the function in-line
# below.

get_letters <- function(n) {
  
# Taking the suggestion of PPBDS to add a basic precaution, since the function
# only works with numeric input
  
  stopifnot(is.numeric(n))
  
# Sampling randomly from letters, taking n letters, with replace = TRUE to
# simulate an actual die (the sides of which don't disappear after they've been
# rolled once)
  
  sample(letters, size = n, replace = TRUE) %>% 
    
# And taking the min of the three letters it outputs (cool to know that you can
# take the alphabetical max and min of strings!)
    
    min()
}

```

A call of my function get_letters() with n = 3 produces the output 
"**`r get_letters(3)`**".

### 5b

```{r question_5b, echo=FALSE}

# This r chunk writes a function (roll_alpha_dice) to call get_letters(3) n
# times, simulating n players each rolling 3 dice and taking the alphabetically
# earliest letter.

roll_alpha_dice <- function(n) {
  
# Again, a basic input precaution  
  
  stopifnot(is.numeric(n))
  
# The map functions confused me for a while, but PPBDS helped a lot by giving me
# code on which to model mine and explaining clearly what each element of the
# code accomplishes. Here, roll_alpha_dice creates a list of length n, the
# result of calling get_letters(3) n times.
  
  map_chr(rep(3, n), get_letters)
}

```

I wrote a cool function called roll_alpha_dice. See what it can do in 5c.

### 5c

```{r question_5c, echo=FALSE}

# This r chunk does three things. First, it creates the tibble tf_game, which
# shows the results of 4 TFs rolling 3 dice and taking the best (alphabetically
# earliest) roll, 100 times. Next, it creates a nice gt table showing the first
# five rows of tf_game (the first five rounds of the 100 games the TFs play).
# Finally, it modifies tf_game to include a logical variable (vowel) showing
# whether the first TF rolled a vowel, and counts how many times vowel is TRUE.

# The first iteration of tf_game: one column (throws) in which each of the 100
# observations is a list of 4 letters

tf_game <- tibble(throws = map(rep(3, 100), ~ roll_alpha_dice(4)))

# Slicing the first five rows to put into a table and calling gt() to make it
# look nice

tf_game %>% 
  slice(1:5) %>% 
  gt() %>% 

# Adding a title and subtitle to make the table easy to understand  
  
  tab_header(title = "Throws of the Alphabet Dice",
             subtitle = "Four players taking the alphabetically earliest of 
             three rolls") %>% 
  
# Adding a column label. Would have been easiest to understand the table if I'd
# separated the list of four letters into a column of its own and given them
# column titles (the names of the four TFs) with "Throws" as a spanner, but that
# seemed like overkill for what should be a fairly simple table, so I didn't do
# it.
    
  cols_label(throws = "Throws") %>% 
  
# Adding footnote to clearly indicate that this is a partial table; not all
# observations are shown.
  
  tab_footnote(footnote = "First five of 100 rows are shown",
               locations = cells_title("title"))

# Part two! Adding the logical vowel column and counting the number of times
# it's TRUE.

n_vowels <- tf_game %>% 
  
# Creating a column (vowel) which returns TRUE if the first element in each
# observation is a vowel, and FALSE if not. Code is modeled closely after the
# example in PPBDS.
  
  mutate(vowel = map_lgl(throws, 
                         ~ ifelse(.[[1]] %in% c("a", "e", "i", "o", "u"), 
                                  TRUE,
                                  FALSE))) %>% 
  
# Now that the column exists, I can filter for the times vowel is TRUE, count
# them, and pull() n to assign the number of vowels to n_vowels, which I'll
# insert in-line below to answer 5c.
  
  filter(vowel == TRUE) %>% 
  count() %>% 
  pull(n)

```

I had **`r n_vowels`** vowels.

### 5d

```{r question_5d, echo=FALSE}

# This r chunk first creates a new tibble (surprised) which is similar to
# tf_game except that 1) instead of the vowel column showing if the first letter
# is a vowel, it has an all_vowels column showing if all four rolls are vowels,
# and 2) it has 10,000 games rather than just 100. It then calculates the
# probability that all four rolls will be vowels.

# I modify the code from the first part of 5c to make a tibble with 10,000 games
# by changing the second argument of rep from 100 to 10000

surprised <- tibble(throws = map(rep(3, 10000), ~ roll_alpha_dice(4))) %>% 
  
# I modify the code from the last part of 5c to use all() and check all elements
# of the list to see if they're vowels instead of just pulling the first
# element. This code is modeled on the example in PPBDS, which was only
# different in that it used any() instead of all().
  
  mutate(all_vowels = map_lgl(throws, 
                              ~ ifelse(all(. %in% c("a", "e", "i", "o", "u")), 
                                  TRUE,
                                  FALSE)))

# Again modeling after the example in PPBDS, I pull() all_vowels and take the
# mean to calculate the probability of rolling all vowels. This is possible
# because mean() treats TRUE as 1 and FALSE as 0 (so it's the same as counting
# the number of TRUE and dividing it by the total number of observations). I
# then assign the mean to prob_all_vowels to insert in-line below.

prob_all_vowels <- surprised %>% 
  pull(all_vowels) %>% 
  mean()

```

The probability that all four TF's roll a vowel is approximately 
**`r prob_all_vowels`**.

### 5e

```{r question_5e, echo=FALSE}

# This r chunk creates a new tibble (first_letters), with the results of 1 TF rolling 1000
# times, and plots its distribution.

# I modify the code from 5c/5d to again make a tibble, this time with 1000 rows
# and just 1 TF, by changing the second rep() argument and the roll_alpha_dice
# argument.

first_letters <- tibble(throws = map(rep(3, 1000), ~ roll_alpha_dice(1))) %>% 
  
# I also take the letters out of lists with unnest() to facilitate easy plotting
  
  unnest(throws)

# I plot the number of throws for each letter, using geom_bar() because it uses
# a discrete x-axis to keep the bars separate

first_letters %>% 
  ggplot(aes(throws)) +
  geom_bar() +
  
# Using theme_classic() to format the chart in a simple way that keeps the
# necessary elements in a neat format (getting rid of grid lines, background
# colors, and the frame outline of the plot)
  
  theme_classic() +
  
# Adding a descriptive title and neat-looking labels for the axes
  
  labs(title = 'Distribution of "First" Letters in 1,000 Rolls of 3 Dice',
       x = "Letter Rolled",
       y = "Count")

```

### 5f

```{r question_5f, echo=FALSE}

# This r chunk plots the distribution of first letters in 1000 rolls of 3 dice
# side-by-side with the distribution of first letters in 1000 rolls of 5 dice.

# First, I create a new function to model throwing five dice (rather than the
# three we threw in the earlier function) by modifying the code for the earlier
# roll_alpha_dice function, changing the first argument of rep() to 5. I
# probably could have saved myself some work by using a parameter instead of
# hard-coding 5, so I'd be able to choose how many dice to roll each time I
# called the function, but I only thought of that after I had this working and
# decided just to stick with it.

roll_alpha_dice_5 <- function(n) {
  stopifnot(is.numeric(n))
  map_chr(rep(5, n), get_letters)
}

# I then modify the code I used to make the first_letters tibble in 5e, changing
# the name of the tibble, the first argument of rep() from 3 to 5, and using
# newly-created roll_alpha_dice_5 instead of roll_alpha_dice. Note that I still
# only have one person rolling, and still unnest() the throws column for easy 
# plotting.

first_letters_5dice <- tibble(throws = map(rep(5, 1000),
                                           ~ roll_alpha_dice_5(1))) %>% 
  unnest(throws)

# I copy and paste the code I used to create the plot in 5e, naming it
# plot_3_dice so I'll be able to insert it later code to plot side-by-side with
# the distribution of first letters using five dice.

plot_3_dice <- first_letters %>% 
  ggplot(aes(throws)) +
  geom_bar() +
  theme_classic() +
  
# Changing the title to make it more concise, for easy side-by-side comparison  
  
  labs(title = 'Distribution of "First" Letters, 3 Dice',
       x = "Letter Rolled",
       y = "Count") +
  
# Manually scaling the y-axis to make it the same as I'll use for the
# distribution of 5 dice, again for easy side-by-side comparison. I chose the
# limit 200 after seeing several iterations of the 5-dice plot, in which the
# highest count was typically between 150-190; I thought 200 would be a safe
# boundary for the 5-dice plot that wouldn't make the scale unduly large for the
# 3-dice plot.
  
  scale_y_continuous(limits = c(0, 200))

# I then modify the code from plot_3_dice to create plot_5_dice, which takes as
# its data first_letters_5dice instead of first_letters but otherwise plots this
# distribution in an identical format to plot_3_dice

plot_5_dice <- first_letters_5dice %>% 
  ggplot(aes(throws)) +
  geom_bar() +
  theme_classic() +
  
# Changing the title to reflect that this is the 5-dice plot  
  
  labs(title = 'Distribution of "First" Letters, 5 Dice',
       x = "Letter Rolled",
       y = "Count") +
  scale_y_continuous(limits = c(0, 200))

# The internet told me that the grid.arrange() function from the gridExtra
# package was good at situating plots neatly side-by-side, and it appears the
# internet was right.

gridExtra::grid.arrange(plot_3_dice, plot_5_dice, ncol = 2)

# Below, I added a brief explanation of the differences between the plots

```

When using five dice instead of three, the distribution compresses toward the left: the counts of the earlier letters (a, b, c, etc.) increase relative to their counts when only three dice are used, and the counts of later letters (z, y, x, etc.) decrease - to the point that fewer unique letters are rolled at all when 5 dice are used.

#### Worked With:
None